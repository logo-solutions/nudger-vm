---
# ==============================================================
# Init master Kubernetes — version stable, idempotente et robuste
# ==============================================================

# Vérifie si le cluster est déjà initialisé
- name: Check if cluster already initialized
  ansible.builtin.stat:
    path: "{{ containerd_kubeconfig_admin_path | default('/etc/kubernetes/admin.conf') }}"
  register: kubeadm_config
  become: true

# Définit l’adresse API si non fournie
- name: Default apiserver_endpoint if undefined
  ansible.builtin.set_fact:
    apiserver_endpoint: "{{ ansible_default_ipv4.address }}:6443"
  when: apiserver_endpoint is not defined or (apiserver_endpoint | trim) == ''

# Prépare le dossier kubeconfig root
- name: Ensure /root/.kube exists
  ansible.builtin.file:
    path: /root/.kube
    state: directory
    mode: "0700"
  become: true
  when: inventory_hostname == groups['k8s_masters'][0]

# Déduit les infos de version (ex: v1.31.13)
- name: Derive k8s_semver and k8s_release (no regex)
  ansible.builtin.set_fact:
    k8s_semver:  "{{ k8s_version.split('-')[0] }}"
    k8s_release: "v{{ k8s_version.split('-')[0] }}"
  when: k8s_version is defined and (k8s_version | length) > 0

# Génère le fichier kubeadm-config.yaml à partir du template
- name: Render kubeadm config
  ansible.builtin.template:
    src: kubeadm-config.j2
    dest: /root/kubeadm-config.yaml
    mode: "0644"
  become: true
  when: inventory_hostname == groups['k8s_masters'][0]

# Initialise le control-plane si non encore fait
- name: Initialize control-plane (skip kube-proxy)
  ansible.builtin.command: >
    kubeadm init --config=/root/kubeadm-config.yaml --skip-phases=addon/kube-proxy
  args:
    creates: "{{ containerd_kubeconfig_admin_path | default('/etc/kubernetes/admin.conf') }}"
  become: true
  when:
    - inventory_hostname == groups['k8s_masters'][0]
    - not kubeadm_config.stat.exists

# Vérifie la présence du manifest kube-apiserver
- name: Stat kube-apiserver manifest
  ansible.builtin.stat:
    path: /etc/kubernetes/manifests/kube-apiserver.yaml
  register: apiserver_manifest
  become: true
  when: inventory_hostname == groups['k8s_masters'][0]

# Si le cluster est partiellement initialisé, rejoue les phases control-plane
- name: Recover control-plane phases if manifest missing
  ansible.builtin.command: kubeadm init phase control-plane all --config=/root/kubeadm-config.yaml
  become: true
  when:
    - inventory_hostname == groups['k8s_masters'][0]
    - kubeadm_config.stat.exists
    - not apiserver_manifest.stat.exists

# Attente que le kube-apiserver écoute sur le port 6443
- name: Wait for kube-apiserver to listen on :6443 (local socket)
  ansible.builtin.shell: |
    for i in $(seq 1 180); do
      if ss -ltn | awk '{print $4}' | grep -qE '(^|:|])6443$'; then
        exit 0
      fi
      sleep 2
    done
    exit 1
  args:
    executable: /bin/bash
  register: apiserver_listen
  changed_when: false
  become: true
  when: inventory_hostname == groups['k8s_masters'][0]

# Vérifie la santé de l’API server (endpoint /readyz)
- name: Wait for API server /readyz to return ok (robust)
  ansible.builtin.shell: |
    set -euo pipefail
    for i in $(seq 1 60); do
      for h in 127.0.0.1 {{ ansible_default_ipv4.address }}; do
        if curl -sf \
          --cacert /etc/kubernetes/pki/ca.crt \
          --cert   /etc/kubernetes/pki/apiserver-kubelet-client.crt \
          --key    /etc/kubernetes/pki/apiserver-kubelet-client.key \
          "https://${h}:6443/readyz" >/dev/null 2>&1; then
          echo ok
          exit 0
        fi
      done
      sleep 2
    done
    exit 1
  args:
    executable: /bin/bash
  changed_when: false
  become: true
  when: inventory_hostname == groups['k8s_masters'][0]

# Copie le kubeconfig admin dans /root/.kube/config
- name: Copy admin kubeconfig to root
  ansible.builtin.copy:
    src: "{{ containerd_kubeconfig_admin_path | default('/etc/kubernetes/admin.conf') }}"
    dest: /root/.kube/config
    remote_src: true
    owner: root
    group: root
    mode: "0600"
  become: true
  when: inventory_hostname == groups['k8s_masters'][0]

# Patch des probes du controller-manager
- name: Patch probes kube-controller-manager to TCP
  ansible.builtin.replace:
    path: /etc/kubernetes/manifests/kube-controller-manager.yaml
    regexp: "(?s)livenessProbe:.*?startupProbe:"
    replace: |
      livenessProbe:
        tcpSocket: { port: 10257 }
        initialDelaySeconds: 10
        periodSeconds: 10
        timeoutSeconds: 15
        failureThreshold: 8
      startupProbe:
        tcpSocket: { port: 10257 }
        initialDelaySeconds: 10
        periodSeconds: 10
        timeoutSeconds: 15
        failureThreshold: 24
    backup: true
  become: true
  when:
    - inventory_hostname == groups['k8s_masters'][0]
    - kubeadm_config.stat.exists

# Patch des probes du scheduler
- name: Patch probes kube-scheduler to TCP
  ansible.builtin.replace:
    path: /etc/kubernetes/manifests/kube-scheduler.yaml
    regexp: "(?s)livenessProbe:.*?startupProbe:"
    replace: |
      livenessProbe:
        tcpSocket:
          port: 10259
        initialDelaySeconds: 10
        periodSeconds: 10
        timeoutSeconds: 15
        failureThreshold: 8
      startupProbe:
        tcpSocket:
          port: 10259
        initialDelaySeconds: 10
        periodSeconds: 10
        timeoutSeconds: 15
        failureThreshold: 24
    backup: true
  become: true
  when:
    - inventory_hostname == groups['k8s_masters'][0]
    - kubeadm_config.stat.exists

# Diagnostic en cas d’échec d’écoute
- name: Debug listen state on failure
  ansible.builtin.shell: |
    set -x
    ss -ltn
    systemctl --no-pager -l status kubelet || true
    journalctl -u kubelet -n 80 --no-pager || true
  args:
    executable: /bin/bash
  changed_when: false
  when: apiserver_listen is failed
  become: true
